<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Performance on Minko Gechev&#39;s blog</title>
    <link>http://blog.mgechev.com/categories/performance/</link>
    <description>Recent content in Performance on Minko Gechev&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 30 Sep 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://blog.mgechev.com/categories/performance/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Lazy Loading of Route Components in Angular 2</title>
      <link>http://blog.mgechev.com/2015/09/30/lazy-loading-components-routes-services-router-angular-2/</link>
      <pubDate>Wed, 30 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://blog.mgechev.com/2015/09/30/lazy-loading-components-routes-services-router-angular-2/</guid>
      <description>Warning: This version of the Angular 2 router is now deprecated! This means that soon the used below APIs will no longer be available.  For the examples in the content below I&amp;rsquo;ve used the angular2-seed project. The code for the article could be found at my GitHub account.
This blog post is mostly about performance and more accurately - lazy loading. Before we get started lets make a quick recap of what problem we&amp;rsquo;re about to solve.</description>
    </item>
    
    <item>
      <title>Even Faster AngularJS Data Structures</title>
      <link>http://blog.mgechev.com/2015/04/20/fast-angular-data-structures-versionable/</link>
      <pubDate>Mon, 20 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://blog.mgechev.com/2015/04/20/fast-angular-data-structures-versionable/</guid>
      <description>This is the last post of the series &amp;ldquo;Boost the Performance of an AngularJS Application Using Immutable Data&amp;rdquo;. I strongly recommend you to take a look at the previous two parts before continue reading this content. You can find them at: - Part 1 - Part 2
Introduction Before about a month ago, I decided to experiment using immutable data structures in an AngularJS application. The goal behind my decision was quite simple - optimization of the $digest loop.</description>
    </item>
    
    <item>
      <title>Boost the Performance of an AngularJS Application Using Immutable Data - Part 2</title>
      <link>http://blog.mgechev.com/2015/04/11/immutability-in-angularjs-immutablejs-part-2/</link>
      <pubDate>Sat, 11 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://blog.mgechev.com/2015/04/11/immutability-in-angularjs-immutablejs-part-2/</guid>
      <description>A few weeks ago I posted the article &amp;ldquo;Boost the Performance of an AngularJS Application Using Immutable Data&amp;rdquo;. It shows how to speedup your AngularJS application when having a lot of bindings to big data collections. The idea behind the optimization is quite simple - create a new collection when the data changes. This way you can reduce the watchers execution from O(n) to O(1).
In the post I did simple profiling using the built-in Date but it didn&amp;rsquo;t give enough information in exactly which cases it is more suitable to use immutable data and when you should bet on the standard collections.</description>
    </item>
    
    <item>
      <title>Boost the Performance of an AngularJS Application Using Immutable Data</title>
      <link>http://blog.mgechev.com/2015/03/02/immutability-in-angularjs-immutablejs/</link>
      <pubDate>Mon, 02 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://blog.mgechev.com/2015/03/02/immutability-in-angularjs-immutablejs/</guid>
      <description>I have affinity to functional programming since my first year in college. During my initial contact with a purely functional programming language (Haskell in my case) I didn&amp;rsquo;t really understand all the advantages it provides, everything was reduced to just writing a cool recursive functions and solving algorithmic problems.
Later, when my code was used in production, I started appreciating things like high-order functions, closures, currying, etc. I even wrote a blog post on topic &amp;ldquo;Functional programming with JavaScript&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Lazy prefetching of AngularJS partials</title>
      <link>http://blog.mgechev.com/2013/10/01/angularjs-partials-lazy-prefetching-strategy-weighted-directed-graph/</link>
      <pubDate>Tue, 01 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>http://blog.mgechev.com/2013/10/01/angularjs-partials-lazy-prefetching-strategy-weighted-directed-graph/</guid>
      <description>This blog post is concentrated about web performance. I&amp;#8217;ll skip the well known stuff about combining images into sprites, inlining images, DNS pre-fetching, combining and minifying script files, gzipping and so on. There are plenty of articles and tools which will help you about these things. There are also excellent researches on these topics, few of the best I&amp;#8217;ve read are these by Mobify, Web Performance Daybook Volume, High Performance Web Sites and Critical rendering path &amp;#8211; Crash course on web performance and many others.</description>
    </item>
    
    <item>
      <title>Looking for performance? Probably you should NOT use [].sort (V8)</title>
      <link>http://blog.mgechev.com/2012/11/24/javascript-sorting-performance-quicksort-v8/</link>
      <pubDate>Sat, 24 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://blog.mgechev.com/2012/11/24/javascript-sorting-performance-quicksort-v8/</guid>
      <description>A few days ago, I&amp;#8217;ve created a GitHub repository. It&amp;#8217;s main goal was to collect different algorithms with implementations in JavaScript. I started with basic ones &amp;#8211; sorting (insertion, selection, bubble sort..). After that I implemented few &amp;#8220;more advance&amp;#8221; like marge, quick and heap sort. It was interesting to me how much slower my implementation will be compared to the default sort. It was so interesting because of:
function sort() { [native code] }  That&amp;#8217;s why I&amp;#8217;ve wrote not optimized version of mergesort and I&amp;#8217;ve run it with generated array with 500k elements.</description>
    </item>
    
    <item>
      <title>Caching CSS with localStorage</title>
      <link>http://blog.mgechev.com/2012/09/04/caching-css-in-the-localstorage/</link>
      <pubDate>Tue, 04 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>http://blog.mgechev.com/2012/09/04/caching-css-in-the-localstorage/</guid>
      <description>Since HTML5 became wide supported the most popular aspects I hear about were it&amp;#8217;s canvas, WebSockets and localStorage. I&amp;#8217;ve got very close experience with the first two of the mentioned but the localStorage was somehow unknown for me since a month. I&amp;#8217;ve researched the topic. Actually it&amp;#8217;s quite interesting and useful as you might guess. Using localStorage you can save different kinds of data locally into key-value pairs. The data lives on your local machine until it&amp;#8217;s deleted (cleared).</description>
    </item>
    
  </channel>
</rss>